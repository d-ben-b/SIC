# 組譯器文件說明

## 目錄

1. [簡介](#簡介)
2. [功能特點](#功能特點)
3. [架構概述](#架構概述)
4. [資料結構](#資料結構)
5. [操作碼與寄存器映射](#操作碼與寄存器映射)
6. [組譯流程](#組譯流程)
   - [第一遍：符號表構建](#第一遍-符號表構建)
   - [第二遍：物件碼生成](#第二遍-物件碼生成)
7. [錯誤處理](#錯誤處理)
8. [使用說明](#使用說明)
   - [Python 組譯器](#python-組譯器)
   - [C 組譯器](#c-組譯器)
9. [範例](#範例)
10. [限制事項](#限制事項)
11. [未來增強](#未來增強)
12. [結論](#結論)

---

## 簡介

本文件提供了一個由 Python 和 C 語言實現的雙遍組譯器的全面概述。該組譯器將組合語言程序轉換為機器可讀的物件碼，遵循 SIC/XE（簡化指令電腦/擴展版）架構。本文件涵蓋了設計、實現細節、使用說明，並提供了範例，以促進對組譯器的理解和有效使用。

## 功能特點

- **雙遍組譯**：
  - **第一遍（Pass 1）**：解析源代碼，分配地址，並建立符號表。
  - **第二遍（Pass 2）**：使用符號表生成物件碼。
- **操作碼與寄存器映射**：支持全面的助記符和寄存器編碼。
- **指令處理**：處理如 `START`、`END`、`BYTE`、`WORD`、`RESW`、`RESB`、`ORG` 和 `EQU` 等組譯器指令。
- **物件檔案生成**：生成符合 SIC/XE 格式的 `H`（標頭）、`T`（文本）和 `E`（結尾）記錄。
- **列表檔案生成**：創建詳細的列表檔案，顯示地址、標籤、助記符、操作數和物件碼。
- **錯誤檢測**：識別並報告如重複符號、未定義符號、無效操作數和語法錯誤等錯誤。
- **可擴展設計**：易於擴展以支持更多指令和功能。

## 架構概述

組譯器主要分為兩個階段：

1. **第一遍（Pass 1）**：

   - **解析**：逐行讀取和解析組合語言源代碼。
   - **符號表構建**：識別標籤並分配地址。
   - **程序計數器（LC）管理**：跟踪每條指令/數據的地址。

2. **第二遍（Pass 2）**：
   - **物件碼生成**：根據符號表生成機器碼。
   - **記錄組裝**：構建符合 `H`、`T` 和 `E` 記錄格式的物件檔案。

組譯器維護內部資料結構，包括每行代碼、符號表、操作碼映射和寄存器映射，以實現高效的處理和轉換。

## 資料結構

### 行結構

代表組合程序中的每一行。

```c
typedef struct {
    char address[7];
    char label[MAX_LABEL_LENGTH];
    char mnemonic[MAX_MNEMONIC_LENGTH];
    char operand[MAX_OPERAND_LENGTH];
    char object_code[MAX_OBJECT_CODE_LENGTH];
} Line;
```

### 符號表

存儲符號（標籤）及其對應地址。

```c
typedef struct {
    char symbol[MAX_LABEL_LENGTH];
    char address[7];
} Symbol;
```

### 操作碼映射

將助記符映射到其對應的操作碼。

```c
typedef struct {
    char mnemonic[MAX_MNEMONIC_LENGTH];
    char opcode[3];
} OpcodeMap;
```

### 寄存器映射

將寄存器名稱映射到其對應的編碼。

```c
typedef struct {
    char reg_name[5];
    char reg_code[2];
} RegisterMap;
```

## 操作碼與寄存器映射

### 操作碼映射

組譯器支持多種指令，這些指令根據不同的格式（格式 1、格式 2、格式 3 和格式 4）分類。每個助記符與其對應的操作碼相關聯。

**範例條目：**

| 助記符 | 操作碼 |
| ------ | ------ |
| LDA    | 00     |
| AND    | 40     |
| ADD    | 18     |
| CLEAR  | B4     |
| RSUB   | 4C     |
| ...    | ...    |

### 寄存器映射

寄存器映射將寄存器名稱與在物件碼生成中使用的特定編碼相關聯。

**範例條目：**

| 寄存器 | 編碼 |
| ------ | ---- |
| A      | 0    |
| X      | 1    |
| L      | 2    |
| B      | 3    |
| PC     | 8    |
| SW     | 9    |
| ...    | ...  |

## 組譯流程

### 第一遍：符號表構建

**目標：**

- **解析行**：讀取並解釋每一行的組合語言源代碼。
- **符號識別**：檢測並記錄帶有對應地址的標籤。
- **程序計數器（LC）管理**：根據指令大小和指令處理地址分配。
- **符號表創建**：建立一個表格，將符號映射到地址，供後續參考使用。

**步驟：**

1. **初始化 LC**：根據 `START` 指令指定的地址開始；如果缺少 `START` 指令，默認為 `0000`。
2. **讀取源代碼行**：逐行處理源代碼。
3. **識別標籤**：如果一行以標籤開始，將其添加到符號表中。
4. **更新 LC**：根據指令或指令處理器大小遞增 LC。
5. **處理指令**：適當處理組譯器指令以管理內存分配和地址分配。

**範例：**

```asm
COPY    START   1000
FIRST   LDA     LENGTH
        ADD     #5
        STA     BUFFER
        CLEAR   A
        COMP    ZERO
        JEQ     END
END     RSUB
LENGTH  WORD    5
BUFFER  RESW    1
ZERO    WORD    0
        END     COPY
```

**生成的符號表：**

| 符號   | 地址 |
| ------ | ---- |
| COPY   | 1000 |
| FIRST  | 1000 |
| LENGTH | 1011 |
| BUFFER | 1014 |
| ZERO   | 1017 |
| END    | 101A |

### 第二遍：物件碼生成

**目標：**

- **翻譯指令**：將助記符和操作數轉換為機器可讀的物件碼。
- **構建物件記錄**：生成符合 SIC/XE 格式的 `H`、`T` 和 `E` 記錄的物件檔案。
- **解析符號**：使用符號表中的實際地址替換符號操作數。
- **處理尋址模式**：正確管理立即、間接和索引尋址模式。

**步驟：**

1. **初始化物件碼**：重置或準備資料結構以生成物件碼。
2. **生成 H-記錄**：創建包含程序名稱、起始地址和程序長度的標頭記錄。
3. **生成 T-記錄**：組裝包含指令和數據的物件碼文本記錄。
4. **生成 E-記錄**：指定程序結尾及起始地址。
5. **處理特殊指令**：如 `RSUB` 指令，生成固定的物件碼。

**物件檔案結構：**

- **H-記錄**：`H[程序名稱][起始地址][程序長度]`
- **T-記錄**：`T[起始地址][記錄長度][物件碼]`
- **E-記錄**：`E[起始地址]`

**範例輸出：**

```
HCOPY  00100000001A
T001000110060111820050C6014B400286017306000
E001000
```

## 錯誤處理

組譯器集成了強大的錯誤檢測機制，能在組譯過程中識別和報告各種類型的錯誤。

### 錯誤類型：

1. **重複符號**：檢測到符號被多次定義。
2. **未定義符號**：識別出使用但未在程序中定義的符號。
3. **無效助記符**：標記在操作碼映射中不存在的助記符。
4. **無效寄存器**：報告無效或不支持的寄存器名稱。
5. **語法錯誤**：捕捉指令或指令處理器中的錯誤語法。
6. **立即值超出範圍**：確保立即值符合預期的位元長度。
7. **無效操作數格式**：檢測操作數結構錯誤，如尋址模式格式錯誤。

### 錯誤報告：

錯誤以描述性訊息形式打印，指出錯誤類型及發生錯誤的行號，便於調試。

**範例錯誤訊息：**

```
Error: Duplicate symbol 'END' at line 10
Error: Undefined symbol 'BUFFER' at line 5
Error: Invalid register 'R1' in instruction at line 7
Error: Immediate value out of range at line 4
Error: Invalid hex string in BYTE at line 3
```

## 使用說明

### Python 組譯器

#### 系統需求：

- 安裝 **Python 3.x**。

#### 運行組譯器：

1. **保存組譯器程式碼**：將提供的 Python 組譯器程式碼保存為 `assembler.py` 文件。

2. **準備輸入文件**：創建包含組合語言程序的文件，例如 `input.asm`。

   ```asm
   COPY    START   1000
   FIRST   LDA     LENGTH
           ADD     #5
           STA     BUFFER
           CLEAR   A
           COMP    ZERO
           JEQ     END
   END     RSUB
   LENGTH  WORD    5
   BUFFER  RESW    1
   ZERO    WORD    0
           END     COPY
   ```

3. **運行組譯器**：使用命令行執行組譯器。

   ```bash
   ./assembler input.asm output.obj output.lst
   ```

4. **檢查輸出文件**：

   - **output.obj**：

     ```
     HCOPY  00100000001A
     T001000110060111820050C6014B400286017306000
     E001000
     ```

   - **output.lst**：

     ```
     Address	Label	Mnemonic	Operand	Object Code
     1000	COPY	START	1000
     1000	FIRST	LDA	LENGTH	006012
     1003		ADD	#5	182005
     1006		STA	BUFFER	0C6015
     1009	CLEAR	A	B400
     100B	COMP	ZERO	286018
     100E	JEQ	END	306000
     1011	END	RSUB	4C0000
     1014	LENGTH	WORD	000005
     1017	BUFFER	RESW	1
     101A	ZERO	WORD	000000
     101D	END	COPY
     ```

#### 注意事項：

- **程序長度**：`H` 記錄中的程序長度準確反映了整個程序的總長度。
- **文本記錄**：`T` 記錄包含不超過 30 字節的物件碼。
- **結尾記錄**：`E` 記錄標記程序結尾並包含正確的起始地址。

### C 組譯器

#### 系統需求：

- 安裝 **C 編譯器**（例如 `gcc`）。

#### 運行組譯器：

1. **保存組譯器程式碼**：將修正後的 C 組譯器程式碼保存為 `assembler.c` 文件。

2. **編譯組譯器**：

   ```bash
   gcc -o assembler assembler.c
   ```

3. **準備輸入文件**：創建包含組合語言程序的文件，例如 `input.asm`。

   ```asm
   COPY    START   1000
   FIRST   LDA     LENGTH
           ADD     #5
           STA     BUFFER
           CLEAR   A
           COMP    ZERO
           JEQ     END
   END     RSUB
   LENGTH  WORD    5
   BUFFER  RESW    1
   ZERO    WORD    0
           END     COPY
   ```

4. **運行組譯器**：

   ```bash
   ./assembler input.asm output.obj output.lst
   ```

5. **檢查輸出文件**：

   - **output.obj**：

     ```
     HCOPY  00100000001A
     T001000110060111820050C6014B400286017306000
     E001000
     ```

   - **output.lst**：

     ```
     Address	Label	Mnemonic	Operand	Object Code
     1000	COPY	START	1000
     1000	FIRST	LDA	LENGTH	006012
     1003		ADD	#5	182005
     1006		STA	BUFFER	0C6015
     1009	CLEAR	A	B400
     100B	COMP	ZERO	286018
     100E	JEQ	END	306000
     1011	END	RSUB	4C0000
     1014	LENGTH	WORD	000005
     1017	BUFFER	RESW	1
     101A	ZERO	WORD	000000
     101D	END	COPY
     ```

#### 注意事項：

- **編譯成功**：確保組譯器無錯誤編譯。
- **正確的物件碼**：`output.obj` 文件應符合預期結構，包含準確的程序長度和物件碼。

## 範例

### 輸入組合語言文件 (`input.asm`)

```asm
COPY    START   1000
FIRST   LDA     LENGTH
        ADD     #5
        STA     BUFFER
        CLEAR   A
        COMP    ZERO
        JEQ     END
END     RSUB
LENGTH  WORD    5
BUFFER  RESW    1
ZERO    WORD    0
        END     COPY
```

### 預期輸出

#### 物件檔案 (`output.obj`)

```
HCOPY  00100000001A
T001000110060111820050C6014B400286017306000
E001000
```

#### 列表檔案 (`output.lst`)

```
Address	Label	Mnemonic	Operand	Object Code
1000	COPY	START	1000
1000	FIRST	LDA	LENGTH	006012
1003		ADD	#5	182005
1006		STA	BUFFER	0C6015
1009	CLEAR	A	B400
100B	COMP	ZERO	286018
100E	JEQ	END	306000
1011	END	RSUB	4C0000
1014	LENGTH	WORD	000005
1017	BUFFER	RESW	1
101A	ZERO	WORD	000000
101D	END	COPY
```

### 解釋：

- **H-記錄**：表示程序名稱 `COPY`、起始地址 `001000` 和程序長度 `001A`（十進位為 26）。
- **T-記錄**：包含可執行指令的物件碼。
- **E-記錄**：標記程序結尾，包含起始地址 `001000`。

## 限制事項

- **指令集**：組譯器支持預定義的助記符和寄存器。新增指令需手動更新操作碼和寄存器映射。
- **尋址模式**：僅支持立即、間接和簡單尋址。索引尋址部分支持。
- **錯誤恢復**：組譯器在遇到錯誤時會報告錯誤但繼續處理，可能導致大型程序中的連鎖錯誤。
- **格式支持**：目前支持格式 1、2 和 3。格式 4 尚未實現。
- **大小寫敏感**：助記符和符號區分大小寫，可能導致不一致。
- **性能**：適用於中小型程序。對於非常大型的組合語言程序，性能可能下降。

## 未來增強

1. **擴展指令集**：增加更多指令和組譯器指令的支持。
2. **格式 4 支持**：實現格式 4 指令的支持，啟用擴展尋址能力。
3. **增強尋址模式**：支持更複雜的尋址模式，包括索引和相對尋址。
4. **改進錯誤處理**：實現更復雜的錯誤恢復機制和詳細錯誤報告。
5. **優化功能**：引入代碼優化技術，提高生成物件碼的效率。
6. **圖形用戶界面（GUI）**：開發用戶友好的 GUI，便於交互和組譯過程的可視化。
7. **跨平台兼容性**：確保在各種操作系統和環境下的兼容性。
8. **文檔與測試**：擴展文檔並實現全面的單元測試，以確保可靠性和可維護性。

## 結論

本組譯器作為將組合語言程序轉換為機器碼的基礎工具，促進了低級軟件的開發和執行。通過 Python 和 C 語言實現，展示了編譯器設計的關鍵原理，包括解析、符號表管理和物件碼生成。雖然功能完善且適用於教育和小型應用，但持續的增強可以擴展其功能、穩定性和可用性，以適應更複雜的應用場景。

---

**作者**：[您的姓名]  
**版本**：1.0  
**日期**：2025-01-08  
**聯繫方式**：[your.email@example.com]
